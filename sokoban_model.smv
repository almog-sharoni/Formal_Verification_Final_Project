
    MODULE main
        DEFINE
            
        rows := 5;
        columns := 5;
       
        
        VAR
            
        keeper_x : 0..4; 
        keeper_y : 0..4; 
        
            box1_x : 0..4;
            box1_y : 0..4;
            box1_on_goal : boolean; 
        
   
        walls : array 0..9 of array 0..9 of boolean; 
        
        goals : array 0..5 of array 0..5 of boolean;
        
        floors : array 0..5 of array 0..5 of boolean;

        action : {u, d, l, r, 0};  

    
           
    ASSIGN 
        init(keeper_x) := 2;
        init(keeper_y) := 3;
        init(action) := 0;
        
            init(box1_x) := 3;  
            init(box1_y) := 2;
            init(box1_on_goal) := FALSE; 
            
                init(walls[0][0]) := TRUE;
                init(goals[0][0]) := FALSE;
                init(floors[0][0]) := TRUE;
                
                init(walls[0][1]) := TRUE;
                init(goals[0][1]) := FALSE;
                init(floors[0][1]) := TRUE;
                
                init(walls[0][2]) := TRUE;
                init(goals[0][2]) := FALSE;
                init(floors[0][2]) := TRUE;
                
                init(walls[0][3]) := TRUE;
                init(goals[0][3]) := FALSE;
                init(floors[0][3]) := TRUE;
                
                init(walls[0][4]) := TRUE;
                init(goals[0][4]) := FALSE;
                init(floors[0][4]) := TRUE;
                
                init(walls[1][0]) := TRUE;
                init(goals[1][0]) := FALSE;
                init(floors[1][0]) := FALSE;
                
                init(walls[1][1]) := TRUE;
                init(goals[1][1]) := FALSE;
                init(floors[1][1]) := TRUE;
                
                init(walls[1][2]) := TRUE;
                init(goals[1][2]) := TRUE;
                init(floors[1][2]) := FALSE;
                
                init(walls[1][3]) := TRUE;
                init(goals[1][3]) := FALSE;
                init(floors[1][3]) := TRUE;
                
                init(walls[1][4]) := TRUE;
                init(goals[1][4]) := FALSE;
                init(floors[1][4]) := FALSE;
                
                init(walls[2][0]) := TRUE;
                init(goals[2][0]) := FALSE;
                init(floors[2][0]) := FALSE;
                
                init(walls[2][1]) := TRUE;
                init(goals[2][1]) := FALSE;
                init(floors[2][1]) := TRUE;
                
                init(walls[2][2]) := FALSE;
                init(goals[2][2]) := FALSE;
                init(floors[2][2]) := FALSE;
                
                init(walls[2][3]) := FALSE;
                init(goals[2][3]) := FALSE;
                init(floors[2][3]) := FALSE;
                
                init(walls[2][4]) := FALSE;
                init(goals[2][4]) := FALSE;
                init(floors[2][4]) := TRUE;
                
                init(walls[3][0]) := TRUE;
                init(goals[3][0]) := FALSE;
                init(floors[3][0]) := FALSE;
                
                init(walls[3][1]) := TRUE;
                init(goals[3][1]) := FALSE;
                init(floors[3][1]) := TRUE;
                
                init(walls[3][2]) := TRUE;
                init(goals[3][2]) := FALSE;
                init(floors[3][2]) := FALSE;
                
                init(walls[3][3]) := FALSE;
                init(goals[3][3]) := FALSE;
                init(floors[3][3]) := FALSE;
                
                init(walls[3][4]) := FALSE;
                init(goals[3][4]) := FALSE;
                init(floors[3][4]) := TRUE;
                
                init(walls[4][0]) := TRUE;
                init(goals[4][0]) := FALSE;
                init(floors[4][0]) := TRUE;
                
                init(walls[4][1]) := TRUE;
                init(goals[4][1]) := FALSE;
                init(floors[4][1]) := TRUE;
                
                init(walls[4][2]) := TRUE;
                init(goals[4][2]) := FALSE;
                init(floors[4][2]) := TRUE;
                
                init(walls[4][3]) := FALSE;
                init(goals[4][3]) := FALSE;
                init(floors[4][3]) := TRUE;
                
                init(walls[4][4]) := FALSE;
                init(goals[4][4]) := FALSE;
                init(floors[4][4]) := TRUE;
                
    
    -- dont need to refer the borders as we have walls
    next(action) := {u, d, l, r, 0};
  
    
    next(keeper_y) := case
            -- keeper_x = 4 : keeper_x; -- Cannot move right if at the right edge
            ((next(action) = u) & (boxes[keeper_x][keeper_y-1] = 1 & (floors[keeper_x][keeper_y-2] = 1 | goals[keeper_x][keeper_y-2] = 1))) : keeper_y - 1;  -- Can move up if there is a box above
            ((next(action) = u) & (floors[keeper_x][keeper_y-1] = 1 | goals[keeper_x][keeper_y-1] = 1)) : keeper_y - 1;  -- Can move up if there is floor or goal above
                
            ((next(action) = d) & (boxes[keeper_x][keeper_y+1] = 1 & (floors[keeper_x][keeper_y+2] = 1 | goals[keeper_x][keeper_y+2] = 1))): keeper_y + 1;  -- Can move down if there is a box below
            ((next(action) = d) & (floors[keeper_x][keeper_y+1] = 1 | goals[keeper_x][keeper_y+1] = 1)): keeper_y + 1;  -- Can move down if there is floor or goal below
                
            TRUE : keeper_y;  -- Default: stay in the same position if no valid move
    esac;

    next(keeper_x) :=  case
            ((next(action) = l) & (boxes[keeper_x-1][keeper_y] = 1 & (floors[keeper_x-2][keeper_y] = 1 | goals[keeper_x-2][keeper_y] = 1))): keeper_x - 1;  -- Can move left if there is a box to the left
            ((next(action) = l) & (floors[keeper_x-1][keeper_y] = 1 | goals[keeper_x-1][keeper_y] = 1)): keeper_x - 1;  -- Can move left if there is floor or goal to the left
                
            ((next(action) = r) & (boxes[keeper_x+1][keeper_y] = 1 & (floors[keeper_x+2][keeper_y] = 1 | goals[keeper_x+2][keeper_y] = 1))): keeper_x + 1;  -- Can move right if there is a box to the right
            ((next(action) = r) & (floors[keeper_x+1][keeper_y] = 1 | goals[keeper_x+1][keeper_y] = 1)): keeper_x + 1;  -- Can move right if there is floor or goal to the right
            
            TRUE : keeper_x;  -- Default: stay in the same position if no valid move
    esac;
    
    
         next(box1_x) := case
         
                next(action) = l & (next(keeper_x) = box1_x & next(keeper_y) = box1_y) : box1_x - 1;  -- Warehouse keeper is pushing box 1
                next(action) = r & (next(keeper_x) = box1_x & next(keeper_y) = box1_y) : box1_x + 1;  -- Warehouse keeper is pushing box 1
                TRUE : box1_x;  -- Default: no movement
        esac;  


        next(box1_y) := case
                next(action) = d & (next(keeper_x) = box1_x & next(keeper_y) = box1_y) : box1_y + 1;  -- Warehouse keeper is pushing box 1
                next(action) = u & (next(keeper_x) = box1_x & next(keeper_y) = box1_y) : box1_y - 1;  -- Warehouse keeper is pushing box 1
                TRUE : box1_y;  -- Default: no movement
        esac;
         
        next(box1_on_goal) := case
            goals[next(box1_x)][next(box1_y)] = 'TRUE' : TRUE;
            TRUE : FALSE;
        
    
        --TRANS
           # --
        next(action) = action;  -- Non-deterministic choice of action
 
    
        LTLSPEC
           F (box1_on_goal)
    