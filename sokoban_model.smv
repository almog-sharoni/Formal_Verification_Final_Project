
    MODULE main 
    VAR
       
    
        wk_x : 0..5; 
        wk_y : 0..4; 
        
        box1_x : 0..5;
        box1_y : 0..4;
        box1_on_goal : boolean; 
        
        walls : array 0..10 of array 0..10 of boolean; 
    
        action : {up, down, left, right};  

    
    ASSIGN 
        init(wk_x) := 2;
        init(wk_y) := 3;
        
        init(box1_x) := 2;  
        init(box1_y) := 2;
        init(box1_on_goal) := FALSE; 
        
            init(walls[0][0]) := TRUE;
            init(walls[0][1]) := TRUE;
            init(walls[0][2]) := TRUE;
            init(walls[0][3]) := TRUE;
            init(walls[0][4]) := TRUE;
            init(walls[0][5]) := TRUE;
            init(walls[0][6]) := TRUE;
            init(walls[0][7]) := TRUE;
            init(walls[0][8]) := TRUE;
            init(walls[0][9]) := TRUE;
            init(walls[1][0]) := TRUE;
            init(walls[1][1]) := TRUE;
            init(walls[1][2]) := TRUE;
            init(walls[1][3]) := TRUE;
            init(walls[1][4]) := TRUE;
            init(walls[1][5]) := TRUE;
            init(walls[1][6]) := TRUE;
            init(walls[1][7]) := TRUE;
            init(walls[1][8]) := TRUE;
            init(walls[1][9]) := TRUE;
            init(walls[2][0]) := TRUE;
            init(walls[2][1]) := TRUE;
            init(walls[2][2]) := FALSE;
            init(walls[2][3]) := FALSE;
            init(walls[2][4]) := FALSE;
            init(walls[2][5]) := FALSE;
            init(walls[2][6]) := FALSE;
            init(walls[2][7]) := FALSE;
            init(walls[2][8]) := TRUE;
            init(walls[2][9]) := TRUE;
            init(walls[3][0]) := TRUE;
            init(walls[3][1]) := TRUE;
            init(walls[3][2]) := TRUE;
            init(walls[3][3]) := FALSE;
            init(walls[3][4]) := FALSE;
            init(walls[3][5]) := FALSE;
            init(walls[3][6]) := FALSE;
            init(walls[3][7]) := TRUE;
            init(walls[3][8]) := TRUE;
            init(walls[3][9]) := TRUE;
            init(walls[4][0]) := TRUE;
            init(walls[4][1]) := TRUE;
            init(walls[4][2]) := TRUE;
            init(walls[4][3]) := FALSE;
            init(walls[4][4]) := FALSE;
            init(walls[4][5]) := FALSE;
            init(walls[4][6]) := FALSE;
            init(walls[4][7]) := TRUE;
            init(walls[4][8]) := TRUE;
            init(walls[4][9]) := TRUE;
            init(walls[5][0]) := TRUE;
            init(walls[5][1]) := TRUE;
            init(walls[5][2]) := TRUE;
            init(walls[5][3]) := FALSE;
            init(walls[5][4]) := FALSE;
            init(walls[5][5]) := TRUE;
            init(walls[5][6]) := FALSE;
            init(walls[5][7]) := TRUE;
            init(walls[5][8]) := TRUE;
            init(walls[5][9]) := TRUE;
            init(walls[6][0]) := TRUE;
            init(walls[6][1]) := TRUE;
            init(walls[6][2]) := FALSE;
            init(walls[6][3]) := FALSE;
            init(walls[6][4]) := FALSE;
            init(walls[6][5]) := FALSE;
            init(walls[6][6]) := FALSE;
            init(walls[6][7]) := FALSE;
            init(walls[6][8]) := TRUE;
            init(walls[6][9]) := TRUE;
            init(walls[7][0]) := TRUE;
            init(walls[7][1]) := TRUE;
            init(walls[7][2]) := TRUE;
            init(walls[7][3]) := TRUE;
            init(walls[7][4]) := TRUE;
            init(walls[7][5]) := TRUE;
            init(walls[7][6]) := TRUE;
            init(walls[7][7]) := TRUE;
            init(walls[7][8]) := TRUE;
            init(walls[7][9]) := TRUE;
            init(walls[8][0]) := TRUE;
            init(walls[8][1]) := TRUE;
            init(walls[8][2]) := TRUE;
            init(walls[8][3]) := TRUE;
            init(walls[8][4]) := TRUE;
            init(walls[8][5]) := TRUE;
            init(walls[8][6]) := TRUE;
            init(walls[8][7]) := TRUE;
            init(walls[8][8]) := TRUE;
            init(walls[8][9]) := TRUE;
     next(walls) := walls;  -- Walls do not change
     next(wk_x) := 
            case
                wk_x = 0 : wk_x;  -- Cannot move left if at the left edge
                wk_x = 5 : wk_x; -- Cannot move right if at the right edge
                action = left & !walls[wk_x - 1][wk_y] : wk_x - 1;   -- Can move right if no wall to the right
                action = right & !walls[wk_x + 1][wk_y] : wk_x + 1;  -- Can move left if no wall to the left
                TRUE : wk_x;  -- Default: stay in the same position if no valid move
            esac;

        next(wk_y) :=  
            case
                wk_y = 0 : wk_y;  -- Cannot move up if at the top edge
                wk_y = 4 : wk_y; -- Cannot move down if at the bottom edge
                action = up & !walls[wk_x][wk_y - 1] : wk_y - 1;  -- Can move down if no wall below
                action = down & !walls[wk_x][wk_y + 1] : wk_y + 1;  -- Can move up if no wall above
                TRUE : wk_y;   -- Default: stay in the same position if no valid move
            esac;
    
         next(box1_x) := 
             case
                 box1_x = 0 : box1_x;  -- Left edge
                 box1_x = 5 : box1_x;  -- Right edge

                 action = left  & !walls[box1_x - 1][box1_y] & wk_x = box1_x + 1 & wk_y = box1_y : box1_x - 1;  -- Space to push
                 action = right  & !walls[box1_x + 1][box1_y] & wk_x = box1_x - 1 & wk_y = box1_y : box1_x + 1;  -- Space to push
                 TRUE : box1_x;  -- Default: no movement
             esac;

         next(box1_y) := 
             case
                 box1_y = 0 : box1_y;  -- Top edge
                 box1_y = 4 : box1_y;  -- Bottom edge 
                 
                 action = down  & !walls[box1_x][box1_y + 1] & wk_x = box1_x & wk_y = box1_y - 1 : box1_y + 1;  -- Space to push
                 action = up  & !walls[box1_x][box1_y - 1] & wk_x = box1_x & wk_y = box1_y + 1 : box1_y - 1;  -- Space to push
                 TRUE : box1_y;  -- Default: no movement
             esac;
             
        next(box1_on_goal) :=
        case
            box1_x = 2 & box1_y = 1 : TRUE;  -- Check if box on goal
            TRUE : FALSE;  -- Default: not on goal
        esac;
        

    TRANS
       
        next(action) = up | next(action) = down | next(action) = right | next(action) = left;  -- Non-deterministic choice of action
 

    LTLSPEC
       X (box1_on_goal)
    